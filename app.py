{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b136d440-b46a-4ec5-9663-75532c1ea109",
   "metadata": {},
   "outputs": [],
   "source": [
    "import streamlit as st\n",
    "import openseespy.opensees as ops\n",
    "import opsvis as opsv\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import os\n",
    "from docx import Document\n",
    "from docx.shared import Cm\n",
    "from docx.enum.text import WD_ALIGN_PARAGRAPH\n",
    "\n",
    "# To handle PDF conversion (works on Windows)\n",
    "try:\n",
    "    import win32com.client\n",
    "    CAN_CONVERT_PDF = True\n",
    "except ImportError:\n",
    "    CAN_CONVERT_PDF = False\n",
    "\n",
    "# --- UI Configuration ---\n",
    "st.set_page_config(layout=\"wide\", page_title=\"Portal Frame Modal Analysis\")\n",
    "st.title(\"AnaStruct: Portal Frame Modal Analysis Tool\")\n",
    "st.write(\"This tool performs a modal analysis on a 2D portal frame using OpenSees and generates a report.\")\n",
    "\n",
    "# --- Define UI Inputs in the Sidebar ---\n",
    "with st.sidebar:\n",
    "    st.header(\"Structural Parameters\")\n",
    "    \n",
    "    niveles = st.slider(\"Number of Levels (Floors)\", 1, 10, 3)\n",
    "    panos = st.slider(\"Number of Bays\", 1, 10, 4)\n",
    "    longitud_pano = st.number_input(\"Bay Length (m)\", value=6.0, min_value=1.0)\n",
    "    altura_nivel = st.number_input(\"Level Height (m)\", value=3.0, min_value=1.0)\n",
    "\n",
    "    st.header(\"Section and Material Properties\")\n",
    "    m = st.number_input(\"Nodal Mass (kg)\", value=1000.0)\n",
    "    A = st.number_input(\"Column Area (A)\", value=0.09)\n",
    "    Ic = st.number_input(\"Column Inertia (Ic)\", value=0.000675, format=\"%.6f\")\n",
    "    Iv = st.number_input(\"Beam Inertia (Iv)\", value=1.0e12) # Kept high for rigid beam assumption\n",
    "    E = st.number_input(\"Modulus of Elasticity (E)\", value=2.0e10)\n",
    "\n",
    "# --- Analysis and Reporting Function ---\n",
    "# Use caching to avoid re-running the entire analysis on every small interaction\n",
    "@st.cache_data\n",
    "def run_analysis(niveles, panos, longitud_pano, altura_nivel, m, A, Ic, Iv, E):\n",
    "    \"\"\"\n",
    "    This function contains the core OpenSees analysis and file generation logic.\n",
    "    It's cached by Streamlit to improve performance.\n",
    "    \"\"\"\n",
    "    # Create the assets directory if it doesn't exist\n",
    "    if not os.path.exists('assets'):\n",
    "        os.makedirs('assets')\n",
    "\n",
    "    # 1. MODEL DEFINITION\n",
    "    ops.wipe()\n",
    "    ops.model('basic', '-ndm', 2, '-ndf', 3)\n",
    "\n",
    "    # 2. NODES AND FIXITIES\n",
    "    nodos = {}\n",
    "    contador_nodo = 1\n",
    "    for i in range(niveles + 1):\n",
    "        for j in range(panos + 1):\n",
    "            x = j * longitud_pano\n",
    "            y = i * altura_nivel\n",
    "            if i == 0:\n",
    "                ops.node(contador_nodo, x, y)\n",
    "                ops.fix(contador_nodo, 1, 1, 1)\n",
    "            else:\n",
    "                ops.node(contador_nodo, x, y, '-mass', m, m, 0)\n",
    "            nodos[(i, j)] = contador_nodo\n",
    "            contador_nodo += 1\n",
    "\n",
    "    # 3. ELEMENTS (Columns and Beams)\n",
    "    geomLinear = 1\n",
    "    ops.geomTransf('Linear', geomLinear)\n",
    "    contador_elemento = 1\n",
    "    \n",
    "    # Columns\n",
    "    for i in range(niveles):\n",
    "        for j in range(panos + 1):\n",
    "            nodo_inferior = nodos[(i, j)]\n",
    "            nodo_superior = nodos[(i + 1, j)]\n",
    "            factor_inercia = (niveles - i) / niveles\n",
    "            ops.element('elasticBeamColumn', contador_elemento, nodo_inferior, nodo_superior, A, E, factor_inercia * Ic, geomLinear)\n",
    "            contador_elemento += 1\n",
    "            \n",
    "    # Beams\n",
    "    for i in range(1, niveles + 1):\n",
    "        for j in range(panos):\n",
    "            nodo_izq = nodos[(i, j)]\n",
    "            nodo_der = nodos[(i, j + 1)]\n",
    "            ops.element('elasticBeamColumn', contador_elemento, nodo_izq, nodo_der, A, E, Iv, geomLinear)\n",
    "            contador_elemento += 1\n",
    "\n",
    "    # Plot and save the structure\n",
    "    opsv.plot_model(fig_wi_he=(12, 9))\n",
    "    plt.title('Parametric Structure', fontsize=14, fontweight='bold')\n",
    "    structure_path = 'assets/estructura_parametrica.png'\n",
    "    plt.savefig(structure_path)\n",
    "    plt.close()\n",
    "\n",
    "    # 4. EIGENVALUE ANALYSIS\n",
    "    NumModos = niveles\n",
    "    try:\n",
    "        eigen_values = np.array(ops.eigen(\"-genBandArpack\", NumModos))\n",
    "        omega = eigen_values**0.5\n",
    "        Tmodes = 2 * np.pi / omega\n",
    "    except Exception as e:\n",
    "        # Handle cases where analysis might fail (e.g., unstable structure)\n",
    "        return None, None, str(e)\n",
    "\n",
    "    # 5. PLOT MODE SHAPES\n",
    "    mode_shape_paths = []\n",
    "    fmt_model = {'color': 'b', 'linestyle': '-', 'linewidth': 2}\n",
    "    fmt_undefo = {'color': 'g', 'linestyle': '--', 'linewidth': 0.7}\n",
    "    for i in range(NumModos):\n",
    "        opsv.plot_mode_shape(i + 1, endDispFlag=0, fmt_undefo=fmt_undefo, fmt_defo=fmt_model)\n",
    "        plt.title(f\"$T_{i+1}$: {Tmodes[i]:.4f} sec\", fontweight='bold')\n",
    "        path = f'assets/modo_{i+1}.png'\n",
    "        plt.savefig(path)\n",
    "        plt.close()\n",
    "        mode_shape_paths.append(path)\n",
    "\n",
    "    return Tmodes, mode_shape_paths, None\n",
    "\n",
    "def create_report(niveles, altura_nivel, panos, longitud_pano, NumModos, Tmodes, mode_shape_paths):\n",
    "    \"\"\"Generates the DOCX report.\"\"\"\n",
    "    document = Document()\n",
    "    titulo = document.add_heading('ANASTRUCT CALCULATION REPORT', 0)\n",
    "    titulo.alignment = WD_ALIGN_PARAGRAPH.CENTER\n",
    "    \n",
    "    p = document.add_paragraph('Report generated by ')\n",
    "    p.add_run('AnaStruct Python Tool. ').bold = True\n",
    "    p.add_run('This code performs a modal analysis of a parametric portal frame.')\n",
    "    p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY\n",
    "\n",
    "    document.add_heading('STRUCTURE GEOMETRY', level=1)\n",
    "    document.add_paragraph('The analyzed structure is shown below:')\n",
    "    document.add_picture('assets/estructura_parametrica.png', width=Cm(15))\n",
    "    \n",
    "    document.add_heading('Structure Data', level=2)\n",
    "    document.add_paragraph(f'Number of Levels = {niveles}', style='List Bullet')\n",
    "    document.add_paragraph(f'Level Height = {altura_nivel}m', style='List Bullet')\n",
    "    document.add_paragraph(f'Number of Bays = {panos}', style='List Bullet')\n",
    "    document.add_paragraph(f'Bay Length = {longitud_pano}m', style='List Bullet')\n",
    "    \n",
    "    document.add_heading('VIBRATION MODES', level=1)\n",
    "    for i in range(NumModos):\n",
    "        document.add_heading(f'Vibration Mode {i + 1}', level=2)\n",
    "        document.add_paragraph(f'Period T{i + 1} = {Tmodes[i]:.4f} sec', style='List Bullet')\n",
    "        document.add_picture(mode_shape_paths[i], width=Cm(15))\n",
    "        \n",
    "    docx_path = \"assets/Calculation_Report.docx\"\n",
    "    document.save(docx_path)\n",
    "    return docx_path\n",
    "\n",
    "# --- Main App Logic ---\n",
    "if st.sidebar.button(\"Run Analysis\", type=\"primary\"):\n",
    "    with st.spinner(\"Running OpenSees analysis... Please wait.\"):\n",
    "        Tmodes, mode_shape_paths, error = run_analysis(\n",
    "            niveles, panos, longitud_pano, altura_nivel, m, A, Ic, Iv, E\n",
    "        )\n",
    "    \n",
    "    if error:\n",
    "        st.error(f\"An error occurred during analysis: {error}\")\n",
    "    else:\n",
    "        st.success(\"Analysis complete!\")\n",
    "        \n",
    "        # Display results in the app\n",
    "        st.header(\"Analysis Results\")\n",
    "        col1, col2 = st.columns(2)\n",
    "        \n",
    "        with col1:\n",
    "            st.subheader(\"Structural Model\")\n",
    "            st.image('assets/estructura_parametrica.png')\n",
    "            \n",
    "        with col2:\n",
    "            st.subheader(\"Calculated Periods\")\n",
    "            for i, T in enumerate(Tmodes):\n",
    "                st.write(f\"**T{i+1}:** {T:.4f} sec\")\n",
    "        \n",
    "        st.header(\"Mode Shapes\")\n",
    "        # Display mode shapes in columns for a cleaner layout\n",
    "        cols = st.columns(len(mode_shape_paths))\n",
    "        for i, path in enumerate(mode_shape_paths):\n",
    "            with cols[i]:\n",
    "                st.image(path, caption=f\"Mode {i+1}\")\n",
    "\n",
    "        # --- Report Generation and Download ---\n",
    "        st.header(\"Download Report\")\n",
    "        with st.spinner(\"Generating report...\"):\n",
    "            docx_path = create_report(niveles, altura_nivel, panos, longitud_pano, niveles, Tmodes, mode_shape_paths)\n",
    "        \n",
    "        # Provide download for DOCX\n",
    "        with open(docx_path, \"rb\") as file:\n",
    "            st.download_button(\n",
    "                label=\"Download Report (DOCX)\",\n",
    "                data=file,\n",
    "                file_name=\"Calculation_Report.docx\",\n",
    "                mime=\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n",
    "            )\n",
    "\n",
    "        # PDF Conversion (only if win32com is available)\n",
    "        if CAN_CONVERT_PDF:\n",
    "            with st.spinner(\"Converting to PDF...\"):\n",
    "                try:\n",
    "                    word = win32com.client.Dispatch('Word.Application')\n",
    "                    doc = word.Documents.Open(os.path.abspath(docx_path))\n",
    "                    pdf_path = os.path.abspath(\"assets/Calculation_Report.pdf\")\n",
    "                    doc.SaveAs(pdf_path, FileFormat=17) # 17 is the wdFormatPDF value\n",
    "                    doc.Close()\n",
    "                    word.Quit()\n",
    "\n",
    "                    with open(pdf_path, \"rb\") as file:\n",
    "                        st.download_button(\n",
    "                            label=\"Download Report (PDF)\",\n",
    "                            data=file,\n",
    "                            file_name=\"Calculation_Report.pdf\",\n",
    "                            mime=\"application/pdf\"\n",
    "                        )\n",
    "                except Exception as e:\n",
    "                    st.warning(f\"Could not convert to PDF. Please do it manually. Error: {e}\")\n",
    "        else:\n",
    "            st.info(\"PDF conversion is only available on Windows with MS Word installed.\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
